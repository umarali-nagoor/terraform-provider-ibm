// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SecurityGroupRule SecurityGroupRule
//
// When 'protocol' is either of 'tcp' or 'udp', then the rule may also contain fields to specify a port range.
// swagger:model security_group_rule
type SecurityGroupRule struct {

	// The ICMP code to to allow. Valid values from 0 to 255. If missing, allow all codes.
	// Required: true
	Code *int64 `json:"code"`

	// The direction of traffic to enforce (ingress, egress)
	// Enum: [ingress egress]
	Direction string `json:"direction,omitempty"`

	// The unique identifier for a security group rule
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// The IP version to enforce (ipv4, ipv6). The format of 'remote.address' or 'remote.cidr_block' must match this field, if they are used. Also, if 'remote' references another security group (ie. using remote.id, remote.name, remote.crn) then this rule will only apply to IP addresses (network interfaces) in that group which match this ip_version.
	// Enum: [ipv4 ipv6]
	IPVersion string `json:"ip_version,omitempty"`

	// The inclusive upper TCP/UDP port bound to enforce. For a single port, set port_min and port_max to5606 the same value. Valid values from 1 to 65535.
	// Required: true
	PortMax *int64 `json:"port_max"`

	// The inclusive lower TCP/UDP port bound to enforce. For a single port, set port_min and port_max to the same value. Valid values from 1 to 65535.
	// Required: true
	PortMin *int64 `json:"port_min"`

	// The protocol to enforce. Must be one of (icmp, tcp, udp, all). Defaults to 'all' if omitted.
	// Enum: [all icmp tcp udp]
	Protocol *string `json:"protocol,omitempty"`

	// remote
	Remote *SecurityGroupRuleRemote `json:"remote,omitempty"`

	// The ICMP type to allow. Valid values from 0 to 255. If missing, allow all types.
	// Required: true
	Type *int64 `json:"type"`
}

// Validate validates this security group rule
func (m *SecurityGroupRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortMax(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortMin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityGroupRule) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("code", "body", m.Code); err != nil {
		return err
	}

	return nil
}

var securityGroupRuleTypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ingress","egress"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityGroupRuleTypeDirectionPropEnum = append(securityGroupRuleTypeDirectionPropEnum, v)
	}
}

const (

	// SecurityGroupRuleDirectionIngress captures enum value "ingress"
	SecurityGroupRuleDirectionIngress string = "ingress"

	// SecurityGroupRuleDirectionEgress captures enum value "egress"
	SecurityGroupRuleDirectionEgress string = "egress"
)

// prop value enum
func (m *SecurityGroupRule) validateDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, securityGroupRuleTypeDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SecurityGroupRule) validateDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.Direction) { // not required
		return nil
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", m.Direction); err != nil {
		return err
	}

	return nil
}

func (m *SecurityGroupRule) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

var securityGroupRuleTypeIPVersionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ipv4","ipv6"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityGroupRuleTypeIPVersionPropEnum = append(securityGroupRuleTypeIPVersionPropEnum, v)
	}
}

const (

	// SecurityGroupRuleIPVersionIPV4 captures enum value "ipv4"
	SecurityGroupRuleIPVersionIPV4 string = "ipv4"

	// SecurityGroupRuleIPVersionIPV6 captures enum value "ipv6"
	SecurityGroupRuleIPVersionIPV6 string = "ipv6"
)

// prop value enum
func (m *SecurityGroupRule) validateIPVersionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, securityGroupRuleTypeIPVersionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SecurityGroupRule) validateIPVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.IPVersion) { // not required
		return nil
	}

	// value enum
	if err := m.validateIPVersionEnum("ip_version", "body", m.IPVersion); err != nil {
		return err
	}

	return nil
}

func (m *SecurityGroupRule) validatePortMax(formats strfmt.Registry) error {

	if err := validate.Required("port_max", "body", m.PortMax); err != nil {
		return err
	}

	return nil
}

func (m *SecurityGroupRule) validatePortMin(formats strfmt.Registry) error {

	if err := validate.Required("port_min", "body", m.PortMin); err != nil {
		return err
	}

	return nil
}

var securityGroupRuleTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","icmp","tcp","udp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityGroupRuleTypeProtocolPropEnum = append(securityGroupRuleTypeProtocolPropEnum, v)
	}
}

const (

	// SecurityGroupRuleProtocolAll captures enum value "all"
	SecurityGroupRuleProtocolAll string = "all"

	// SecurityGroupRuleProtocolIcmp captures enum value "icmp"
	SecurityGroupRuleProtocolIcmp string = "icmp"

	// SecurityGroupRuleProtocolTCP captures enum value "tcp"
	SecurityGroupRuleProtocolTCP string = "tcp"

	// SecurityGroupRuleProtocolUDP captures enum value "udp"
	SecurityGroupRuleProtocolUDP string = "udp"
)

// prop value enum
func (m *SecurityGroupRule) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, securityGroupRuleTypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SecurityGroupRule) validateProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *SecurityGroupRule) validateRemote(formats strfmt.Registry) error {

	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityGroupRule) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityGroupRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityGroupRule) UnmarshalBinary(b []byte) error {
	var res SecurityGroupRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityGroupRuleRemote SecurityGroupReference
//
// Describe the set of network interfaces from which this rule allows traffic (or to which, for egress rules.)
// swagger:model SecurityGroupRuleRemote
type SecurityGroupRuleRemote struct {

	// A single IPv4 or IPv6 address.
	Address string `json:"address,omitempty"`

	// A range of IPv4 or IPv6 addresses, in CIDR format.
	CidrBlock string `json:"cidr_block,omitempty"`

	// The security group's CRN
	Crn string `json:"crn,omitempty"`

	// The security group's canonical URL.
	// Pattern: ^http(s)?:\/\/([^\/?#]*)([^?#]*)(\?([^#]*))?(#(.*))?$
	Href string `json:"href,omitempty"`

	// The security group's unique identifier.
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// The security group's user-defined name.
	// Pattern: ^[A-Za-z][-A-Za-z0-9_]*$
	Name string `json:"name,omitempty"`
}

// Validate validates this security group rule remote
func (m *SecurityGroupRuleRemote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHref(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityGroupRuleRemote) validateHref(formats strfmt.Registry) error {

	if swag.IsZero(m.Href) { // not required
		return nil
	}

	if err := validate.Pattern("remote"+"."+"href", "body", string(m.Href), `^http(s)?:\/\/([^\/?#]*)([^?#]*)(\?([^#]*))?(#(.*))?$`); err != nil {
		return err
	}

	return nil
}

func (m *SecurityGroupRuleRemote) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("remote"+"."+"id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SecurityGroupRuleRemote) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.Pattern("remote"+"."+"name", "body", string(m.Name), `^[A-Za-z][-A-Za-z0-9_]*$`); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityGroupRuleRemote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityGroupRuleRemote) UnmarshalBinary(b []byte) error {
	var res SecurityGroupRuleRemote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
